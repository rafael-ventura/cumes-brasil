"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetCompareExchangeValuesCommand = exports.GetCompareExchangeValuesOperation = void 0;
const Exceptions_1 = require("../../../Exceptions");
const RavenCommand_1 = require("../../../Http/RavenCommand");
const CompareExchangeValueResultParser_1 = require("./CompareExchangeValueResultParser");
const StringBuilder_1 = require("../../../Utility/StringBuilder");
const TypeUtil_1 = require("../../../Utility/TypeUtil");
class GetCompareExchangeValuesOperation {
    get keys() {
        return this._keys;
    }
    get startWith() {
        return this._startWith;
    }
    get start() {
        return this._start;
    }
    get pageSize() {
        return this._pageSize;
    }
    get clazz() {
        return this._clazz;
    }
    constructor(parameters) {
        this._clazz = parameters.clazz;
        this._materializeMetadata = parameters.materializeMetadata || true;
        if (parameters.keys) {
            if (!parameters.keys.length) {
                (0, Exceptions_1.throwError)("InvalidArgumentException", "Keys cannot be an empty array.");
            }
            this._keys = parameters.keys;
        }
        else if (!TypeUtil_1.TypeUtil.isNullOrUndefined(parameters.startWith)) {
            this._startWith = parameters.startWith;
            this._start = parameters.start;
            this._pageSize = parameters.pageSize;
        }
        else {
            (0, Exceptions_1.throwError)("InvalidArgumentException", "Please specify at least keys or startWith parameter");
        }
    }
    getCommand(store, conventions, cache) {
        return new GetCompareExchangeValuesCommand(this, this._materializeMetadata, conventions);
    }
    get resultType() {
        return "CommandResult";
    }
}
exports.GetCompareExchangeValuesOperation = GetCompareExchangeValuesOperation;
class GetCompareExchangeValuesCommand extends RavenCommand_1.RavenCommand {
    constructor(operation, materializeMetadata, conventions) {
        super();
        this._operation = operation;
        this._materializeMetadata = materializeMetadata;
        this._conventions = conventions;
    }
    get isReadRequest() {
        return true;
    }
    createRequest(node) {
        const pathBuilder = new StringBuilder_1.StringBuilder(node.url);
        pathBuilder.append("/databases/")
            .append(node.database)
            .append("/cmpxchg?");
        if (this._operation.keys) {
            for (const key of this._operation.keys) {
                pathBuilder.append("&key=").append(encodeURIComponent(key));
            }
        }
        else {
            if (this._operation.startWith) {
                pathBuilder.append("&startsWith=")
                    .append(encodeURIComponent(this._operation.startWith));
            }
            if (this._operation.start) {
                pathBuilder.append("&start=")
                    .append(this._operation.start);
            }
            if (this._operation.pageSize) {
                pathBuilder.append("&pageSize=")
                    .append(this._operation.pageSize);
            }
        }
        const uri = pathBuilder.toString();
        return { uri };
    }
    async setResponseAsync(bodyStream, fromCache) {
        let body = null;
        if (!bodyStream) {
            this.result = {};
            return body;
        }
        const results = await this._pipeline()
            .collectBody(b => body = b)
            .parseJsonSync()
            .process(bodyStream);
        const localObject = GetCompareExchangeValuesCommand.mapToLocalObject(results);
        this.result = CompareExchangeValueResultParser_1.CompareExchangeValueResultParser.getValues(localObject, this._materializeMetadata, this._conventions, this._operation.clazz);
        return body;
    }
    static mapToLocalObject(json) {
        return {
            results: json.Results.map(item => {
                if (!item.Value) {
                    return {
                        index: item.Index,
                        key: item.Key,
                        value: null
                    };
                }
                const { Object, ...rest } = item.Value;
                return {
                    value: {
                        ...rest,
                        object: Object
                    },
                    index: item.Index,
                    key: item.Key
                };
            })
        };
    }
}
exports.GetCompareExchangeValuesCommand = GetCompareExchangeValuesCommand;
//# sourceMappingURL=GetCompareExchangeValuesOperation.js.map