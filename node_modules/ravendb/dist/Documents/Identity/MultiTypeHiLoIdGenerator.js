"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultiTypeHiLoIdGenerator = void 0;
const HiloIdGenerator_1 = require("./HiloIdGenerator");
const semaphore = require("semaphore");
const SemaphoreUtil_1 = require("../../Utility/SemaphoreUtil");
class MultiTypeHiLoIdGenerator {
    constructor(store, dbName) {
        this._idGeneratorsByTag = {};
        this._store = store;
        this._dbName = dbName;
        this._sem = semaphore();
        this._conventions = store.getRequestExecutor(dbName).conventions;
        this._identityPartsSeparator = this._conventions.identityPartsSeparator;
    }
    async generateDocumentId(entity, documentType) {
        const identityPartsSeparator = this._conventions.identityPartsSeparator;
        if (this._identityPartsSeparator !== identityPartsSeparator) {
            await this._maybeRefresh(identityPartsSeparator);
        }
        const entityType = this._conventions.getJsTypeByDocumentType(documentType);
        const typeTagName = entityType
            ? this._conventions.getCollectionNameForType(entityType)
            : this._conventions.getCollectionNameForEntity(entity);
        if (!typeTagName) {
            return Promise.resolve(null);
        }
        const tag = await this._conventions.transformClassCollectionNameToDocumentIdPrefix(typeTagName);
        let value = this._idGeneratorsByTag[tag];
        if (value) {
            return await value.generateDocumentId(entity);
        }
        const acquiredSem = (0, SemaphoreUtil_1.acquireSemaphore)(this._sem);
        await acquiredSem.promise;
        try {
            value = this._idGeneratorsByTag[tag];
            if (value) {
                return value.generateDocumentId(entity);
            }
            value = this._createGeneratorFor(tag);
            this._idGeneratorsByTag[tag] = value;
        }
        finally {
            acquiredSem.dispose();
        }
        return value.generateDocumentId(entity);
    }
    async _maybeRefresh(identityPartsSeparator) {
        let idGenerators;
        const acquiredSem = (0, SemaphoreUtil_1.acquireSemaphore)(this._sem);
        try {
            await acquiredSem.promise;
            if (this._identityPartsSeparator === identityPartsSeparator) {
                return;
            }
            idGenerators = Object.entries(this._idGeneratorsByTag).map(x => x[1]);
            this._idGeneratorsByTag = {};
            this._identityPartsSeparator = identityPartsSeparator;
        }
        finally {
            acquiredSem.dispose();
        }
        if (idGenerators) {
            try {
                await MultiTypeHiLoIdGenerator._returnUnusedRange(idGenerators);
            }
            catch {
            }
        }
    }
    async generateNextIdFor(collectionName) {
        let value = this._idGeneratorsByTag[collectionName];
        if (value) {
            return value.nextId();
        }
        const acquiredSem = (0, SemaphoreUtil_1.acquireSemaphore)(this._sem);
        try {
            await acquiredSem.promise;
            value = this._idGeneratorsByTag[collectionName];
            if (value) {
                return value.nextId();
            }
            value = this._createGeneratorFor(collectionName);
            this._idGeneratorsByTag[collectionName] = value;
        }
        finally {
            acquiredSem.dispose();
        }
        return value.nextId();
    }
    _createGeneratorFor(tag) {
        return new HiloIdGenerator_1.HiloIdGenerator(tag, this._store, this._dbName, this._identityPartsSeparator);
    }
    async returnUnusedRange() {
        await MultiTypeHiLoIdGenerator._returnUnusedRange(Object.values(this._idGeneratorsByTag));
    }
    static async _returnUnusedRange(generators) {
        for (const generator of generators) {
            await generator.returnUnusedRange();
        }
    }
}
exports.MultiTypeHiLoIdGenerator = MultiTypeHiLoIdGenerator;
//# sourceMappingURL=MultiTypeHiLoIdGenerator.js.map