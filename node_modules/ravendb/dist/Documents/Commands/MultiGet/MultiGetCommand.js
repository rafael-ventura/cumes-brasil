"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultiGetCommand = void 0;
const RavenCommand_1 = require("../../../Http/RavenCommand");
const GetResponse_1 = require("./GetResponse");
const StatusCode_1 = require("../../../Http/StatusCode");
const HttpUtil_1 = require("../../../Utility/HttpUtil");
const Exceptions_1 = require("../../../Exceptions");
const Constants_1 = require("../../../Constants");
const change_case_1 = require("change-case");
class MultiGetCommand extends RavenCommand_1.RavenCommand {
    constructor(requestExecutor, conventions, commands) {
        super();
        this._requestExecutor = requestExecutor;
        if (!requestExecutor) {
            (0, Exceptions_1.throwError)("InvalidArgumentException", "RequestExecutor cannot be null");
        }
        this._httpCache = requestExecutor.cache;
        if (!commands) {
            (0, Exceptions_1.throwError)("InvalidArgumentException", "Commands cannot be null");
        }
        this._commands = commands;
        this._conventions = conventions;
        this._responseType = "Raw";
    }
    _getCacheKey(command) {
        const url = this._baseUrl + command.urlAndQuery;
        return (command.method || "GET") + "-" + url;
    }
    createRequest(node) {
        this._baseUrl = node.url + "/databases/" + node.database;
        const requests = [];
        const bodyObj = { Requests: requests };
        const request = {
            uri: this._baseUrl + "/multi_get",
            method: "POST",
            headers: this._headers().typeAppJson().build(),
        };
        if (this._maybeReadAllFromCache(this._requestExecutor.aggressiveCaching)) {
            this.aggressivelyCached = true;
            return null;
        }
        for (const command of this._commands) {
            const req = {
                Url: "/databases/" + node.database + command.url,
                Query: command.query,
                Method: command.method || "GET",
                Headers: command.headers,
                Content: command.body
            };
            requests.push(req);
        }
        request.body = JSON.stringify(bodyObj);
        return request;
    }
    _maybeReadAllFromCache(options) {
        this.closeCache();
        let readAllFromCache = !!options;
        for (let i = 0; i < this._commands.length; i++) {
            const command = this._commands[i];
            const cacheKey = this._getCacheKey(command);
            let changeVector;
            let cachedRef;
            const cachedItem = this._httpCache.get(cacheKey, c => {
                changeVector = c.changeVector;
                cachedRef = c.response;
            });
            if (!cachedItem.item) {
                readAllFromCache = false;
                continue;
            }
            if (readAllFromCache && cachedItem.age > options.duration || !command.canCacheAggressively) {
                readAllFromCache = false;
            }
            command.headers[Constants_1.HEADERS.IF_NONE_MATCH] = changeVector;
            if (!this._cached) {
                this._cached = new Cached(this._commands.length);
            }
            this._cached.values[i] = [cachedItem, cachedRef];
        }
        if (readAllFromCache) {
            try {
                this.result = [];
                for (let i = 0; i < this._commands.length; i++) {
                    const itemAndCached = this._cached.values[i];
                    const getResponse = new GetResponse_1.GetResponse();
                    getResponse.result = itemAndCached[1];
                    getResponse.statusCode = StatusCode_1.StatusCodes.NotModified;
                    this.result.push(getResponse);
                }
            }
            finally {
                this._cached.dispose();
            }
            this._cached = null;
        }
        return readAllFromCache;
    }
    async setResponseAsync(bodyStream, fromCache) {
        if (!bodyStream) {
            this._throwInvalidResponse();
        }
        try {
            const result = await this._pipeline()
                .parseJsonSync()
                .process(bodyStream);
            const responses = result.Results.map(item => MultiGetCommand._mapToLocalObject(item));
            this.result = [];
            for (let i = 0; i < responses.length; i++) {
                const res = responses[i];
                const command = this._commands[i];
                this._maybeSetCache(res, command, i);
                if (this._cached && res.statusCode === StatusCode_1.StatusCodes.NotModified) {
                    const clonedResponse = new GetResponse_1.GetResponse();
                    clonedResponse.result = this._cached.values[i][1];
                    clonedResponse.statusCode = StatusCode_1.StatusCodes.NotModified;
                    this.result.push(clonedResponse);
                }
                else {
                    this.result.push(GetResponse_1.GetResponse.create(res));
                }
            }
            return null;
        }
        finally {
            if (this._cached) {
                this._cached.dispose();
            }
        }
    }
    _maybeSetCache(getResponse, command, cachedIndex) {
        if (getResponse.statusCode === StatusCode_1.StatusCodes.NotModified) {
            if (this._cached) {
                this._cached.values[cachedIndex][0].notModified();
            }
            return;
        }
        const cacheKey = this._getCacheKey(command);
        const result = getResponse.result;
        if (!result) {
            this._httpCache.setNotFound(cacheKey);
            return;
        }
        const changeVector = (0, HttpUtil_1.getEtagHeader)(getResponse.headers);
        if (!changeVector) {
            return;
        }
        this._httpCache.set(cacheKey, changeVector, result);
    }
    get isReadRequest() {
        return false;
    }
    dispose() {
        this.closeCache();
    }
    closeCache() {
        if (this._cached) {
            this._cached.dispose();
            this._cached = null;
            for (const command of this._commands) {
                delete command.headers[Constants_1.HEADERS.IF_NONE_MATCH];
            }
        }
    }
    static _mapToLocalObject(json) {
        const item = {};
        for (const [key, value] of Object.entries(json)) {
            item[(0, change_case_1.camelCase)(key)] = value;
        }
        item.result = item.result ? JSON.stringify(item.result) : null;
        return item;
    }
}
exports.MultiGetCommand = MultiGetCommand;
class Cached {
    constructor(size) {
        this._size = size;
        this.values = new Array(size);
    }
    dispose() {
        if (!this.values) {
            return;
        }
        this.values = null;
    }
}
//# sourceMappingURL=MultiGetCommand.js.map