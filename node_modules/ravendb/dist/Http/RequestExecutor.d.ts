/// <reference types="node" />
import { ServerNode } from "./ServerNode";
import { RavenCommand } from "./RavenCommand";
import { Topology } from "./Topology";
import { NodeSelector } from "./NodeSelector";
import { IDisposable } from "../Types/Contracts";
import { IRequestAuthOptions, IAuthOptions } from "../Auth/AuthOptions";
import { ICertificate } from "../Auth/Certificate";
import { HttpCache } from "./HttpCache";
import { AggressiveCacheOptions } from "./AggressiveCacheOptions";
import CurrentIndexAndNode from "./CurrentIndexAndNode";
import { HttpRequestParameters, HttpRequestParametersWithoutUri } from "../Primitives/Http";
import { DocumentConventions } from "../Documents/Conventions/DocumentConventions";
import { SessionInfo } from "../Documents/Session/IDocumentSession";
import { PromiseStatusTracker } from "../Utility/PromiseUtil";
import type * as http from "http";
import AbortController from "abort-controller";
import { BeforeRequestEventArgs, FailedRequestEventArgs, SucceedRequestEventArgs, TopologyUpdatedEventArgs } from "../Documents/Session/SessionEvents";
import { UpdateTopologyParameters } from "./UpdateTopologyParameters";
export interface ExecuteOptions<TResult> {
    chosenNode: ServerNode;
    nodeIndex: number;
    shouldRetry: boolean;
    abortRef?: (controller: AbortController) => void;
}
export interface ITopologyUpdateEvent {
    topologyJson: object;
    serverNodeUrl: string;
    requestedDatabase?: string;
    forceUpdate?: boolean;
    wasUpdated?: boolean;
}
export interface IRequestExecutorOptions {
    authOptions?: IRequestAuthOptions;
    documentConventions?: DocumentConventions;
}
export declare class NodeStatus implements IDisposable {
    private _nodeStatusCallback;
    private _timerPeriodInMs;
    readonly nodeIndex: number;
    readonly node: ServerNode;
    readonly requestExecutor: RequestExecutor;
    private _timer;
    constructor(nodeIndex: number, node: ServerNode, requestExecutor: RequestExecutor, nodeStatusCallback: (nodeStatus: NodeStatus) => Promise<void>);
    private _nextTimerPeriod;
    startTimer(): void;
    updateTimer(): void;
    dispose(): void;
}
export declare class RequestExecutor implements IDisposable {
    private _emitter;
    private static GLOBAL_APPLICATION_IDENTIFIER;
    private static readonly INITIAL_TOPOLOGY_ETAG;
    private _log;
    static readonly CLIENT_VERSION = "5.4.0";
    private _updateDatabaseTopologySemaphore;
    private _updateClientConfigurationSemaphore;
    private static _backwardCompatibilityFailureCheckOperation;
    private static readonly _failureCheckOperation;
    private static _useOldFailureCheckOperation;
    private _failedNodesTimers;
    protected _databaseName: string;
    protected _certificate: ICertificate;
    private _lastReturnedResponse;
    private readonly _cache;
    private _topologyTakenFromNode;
    aggressiveCaching: AggressiveCacheOptions;
    private _updateTopologyTimer;
    protected _nodeSelector: NodeSelector;
    private _defaultTimeout;
    numberOfServerRequests: number;
    protected _disposed: boolean;
    private _firstTopologyUpdatePromiseInternal;
    private _httpAgent;
    private static KEEP_ALIVE_HTTP_AGENT;
    private static readonly HTTPS_AGENT_CACHE;
    protected get _firstTopologyUpdatePromise(): Promise<void>;
    protected set _firstTopologyUpdatePromise(value: Promise<void>);
    protected _firstTopologyUpdateStatus: PromiseStatusTracker<void>;
    protected _lastKnownUrls: string[];
    protected _clientConfigurationEtag: string;
    protected _topologyEtag: number;
    private readonly _conventions;
    private readonly _authOptions;
    protected _disableTopologyUpdates: boolean;
    protected _disableClientConfigurationUpdates: boolean;
    protected _lastServerVersion: string;
    protected _customHttpRequestOptions: HttpRequestParametersWithoutUri;
    protected _defaultRequestOptions: HttpRequestParametersWithoutUri;
    static requestPostProcessor: (req: HttpRequestParameters) => void;
    get customHttpRequestOptions(): HttpRequestParametersWithoutUri;
    set customHttpRequestOptions(value: HttpRequestParametersWithoutUri);
    getAuthOptions(): IAuthOptions;
    getTopologyEtag(): number;
    get lastServerVersion(): string;
    get defaultTimeout(): number;
    set defaultTimeout(timeout: number);
    private _secondBroadcastAttemptTimeout;
    get secondBroadcastAttemptTimeout(): number;
    set secondBroadcastAttemptTimeout(timeout: number);
    private _firstBroadcastAttemptTimeout;
    get firstBroadcastAttemptTimeout(): number;
    set firstBroadcastAttemptTimeout(timeout: number);
    on(event: "topologyUpdated", handler: (value: TopologyUpdatedEventArgs) => void): any;
    on(event: "failedRequest", handler: (value: FailedRequestEventArgs) => void): any;
    on(event: "beforeRequest", handler: (value: BeforeRequestEventArgs) => void): any;
    on(event: "succeedRequest", handler: (value: SucceedRequestEventArgs) => void): any;
    off(event: "topologyUpdated", handler: (value: TopologyUpdatedEventArgs) => void): any;
    off(event: "failedRequest", handler: (value: FailedRequestEventArgs) => void): any;
    off(event: "beforeRequest", handler: (value: BeforeRequestEventArgs) => void): any;
    off(event: "succeedRequest", handler: (value: SucceedRequestEventArgs) => void): any;
    private _onFailedRequestInvoke;
    get conventions(): DocumentConventions;
    getClientConfigurationEtag(): string;
    get cache(): HttpCache;
    get disposed(): boolean;
    getUrl(): string;
    getTopology(): Topology;
    getHttpAgent(): http.Agent;
    private _createHttpAgent;
    private static assertKeepAliveAgent;
    getTopologyNodes(): ServerNode[];
    protected constructor(database: string, authOptions: IRequestAuthOptions, conventions: DocumentConventions);
    static create(initialUrls: string[], database: string): RequestExecutor;
    static create(initialUrls: string[], database: string, opts?: IRequestExecutorOptions): RequestExecutor;
    private static getGlobalApplicationIdentifier;
    static createForSingleNodeWithConfigurationUpdates(url: string, database: string, opts: IRequestExecutorOptions): RequestExecutor;
    static createForSingleNodeWithoutConfigurationUpdates(url: string, database: string, opts: IRequestExecutorOptions): RequestExecutor;
    protected _updateClientConfiguration(serverNode: ServerNode): Promise<void>;
    private _updateClientConfigurationInternal;
    updateTopology(parameters: UpdateTopologyParameters): Promise<boolean>;
    protected _disposeAllFailedNodesTimers(): void;
    execute<TResult>(command: RavenCommand<TResult>): Promise<void>;
    execute<TResult>(command: RavenCommand<TResult>, sessionInfo?: SessionInfo): Promise<void>;
    execute<TResult>(command: RavenCommand<TResult>, sessionInfo?: SessionInfo, options?: ExecuteOptions<TResult>): Promise<void>;
    chooseNodeForRequest<TResult>(cmd: RavenCommand<TResult>, sessionInfo: SessionInfo): CurrentIndexAndNode;
    private _unlikelyExecute;
    private _waitForTopologyUpdate;
    private _updateTopologyCallback;
    protected _firstTopologyUpdate(inputUrls: string[], applicationIdentifier?: string): Promise<void>;
    protected _throwExceptions(details: string): void;
    static validateUrls(initialUrls: string[], authOptions: IAuthOptions): any[];
    private _initializeUpdateTopologyTimer;
    private _executeOnSpecificNode;
    private _refreshIfNeeded;
    private _sendRequestToServer;
    private _send;
    private _setRequestHeaders;
    private _tryGetFromCache;
    private static _tryGetServerVersion;
    private _throwFailedToContactAllNodes;
    inSpeedTestPhase(): boolean;
    private _shouldExecuteOnAll;
    private _executeOnAllToFigureOutTheFastest;
    private _getFromCache;
    private _nodeSelectorHasMultipleNodes;
    private _createRequest;
    private _handleUnsuccessfulResponse;
    private static _handleConflict;
    private _handleServerDown;
    private _shouldBroadcast;
    private _broadcast;
    private _waitForBroadcastResult;
    private _sendToAllNodes;
    handleServerNotResponsive(url: string, chosenNode: ServerNode, nodeIndex: number, e: Error): Promise<ServerNode>;
    private _spawnHealthChecks;
    private _checkNodeStatusCallback;
    protected _performHealthCheck(serverNode: ServerNode, nodeIndex: number): Promise<void>;
    private _executeOldHealthCheck;
    private static _readExceptionFromServer;
    private _setDefaultRequestOptions;
    dispose(): void;
    getRequestedNode(nodeTag: string, throwIfContainsFailures?: boolean): Promise<CurrentIndexAndNode>;
    getPreferredNode(): Promise<CurrentIndexAndNode>;
    getNodeBySessionId(sessionId: number): Promise<CurrentIndexAndNode>;
    getFastestNode(): Promise<CurrentIndexAndNode>;
    private _ensureNodeSelector;
    protected _onTopologyUpdatedInvoke(newTopology: Topology): void;
}
